//
//  RESong.cpp
//  soul-sifter
//
//  Created by Robby Neale
//  Generated by generate_model.rb
//

#include "RESong.h"

#include <cmath>
#include <string>
#include <sstream>

#include <boost/regex.hpp>
#include <boost/algorithm/string.hpp>
#include <jdbc/cppconn/connection.h>
#include <jdbc/cppconn/statement.h>
#include <jdbc/cppconn/prepared_statement.h>
#include <jdbc/cppconn/resultset.h>
#include <jdbc/cppconn/exception.h>
#include <jdbc/cppconn/warning.h>
#include <g3log/g3log.hpp>

#include "AlertsChannel.h"
#include "MysqlAccess.h"
#include "DTVectorUtil.h"

using namespace std;

namespace dogatech {
namespace soulsifter {

# pragma mark initialization

    RESong::RESong() :
    id(0),
    songidWinfo(),
    songid(),
    shortid(),
    shortidWinfo(),
    artist(),
    album(),
    track(),
    title(),
    time(),
    timeSignature(),
    filename(),
    digitalOnly(),
    compilation(),
    keyStart(),
    keyAccuracy(0),
    bpmStart(),
    bpmAccuracy(0),
    rating(0),
    dateAdded(),
    catalogId(),
    label(),
    remix(),
    numPlays(0),
    comments(),
    releaseDate(),
    featuring(),
    keyEnd(),
    disabled(),
    bpmEnd(),
    beatIntensity(0),
    replayGain(),
    stylesBitmask() {
    }

    RESong::RESong(const RESong& reSong) :
    id(reSong.getId()),
    songidWinfo(reSong.getSongidWinfo()),
    songid(reSong.getSongid()),
    shortid(reSong.getShortid()),
    shortidWinfo(reSong.getShortidWinfo()),
    artist(reSong.getArtist()),
    album(reSong.getAlbum()),
    track(reSong.getTrack()),
    title(reSong.getTitle()),
    time(reSong.getTime()),
    timeSignature(reSong.getTimeSignature()),
    filename(reSong.getFilename()),
    digitalOnly(reSong.getDigitalOnly()),
    compilation(reSong.getCompilation()),
    keyStart(reSong.getKeyStart()),
    keyAccuracy(reSong.getKeyAccuracy()),
    bpmStart(reSong.getBpmStart()),
    bpmAccuracy(reSong.getBpmAccuracy()),
    rating(reSong.getRating()),
    dateAdded(reSong.getDateAdded()),
    catalogId(reSong.getCatalogId()),
    label(reSong.getLabel()),
    remix(reSong.getRemix()),
    numPlays(reSong.getNumPlays()),
    comments(reSong.getComments()),
    releaseDate(reSong.getReleaseDate()),
    featuring(reSong.getFeaturing()),
    keyEnd(reSong.getKeyEnd()),
    disabled(reSong.getDisabled()),
    bpmEnd(reSong.getBpmEnd()),
    beatIntensity(reSong.getBeatIntensity()),
    replayGain(reSong.getReplayGain()),
    stylesBitmask(reSong.getStylesBitmask()) {
    }

    void RESong::operator=(const RESong& reSong) {
        id = reSong.getId();
        songidWinfo = reSong.getSongidWinfo();
        songid = reSong.getSongid();
        shortid = reSong.getShortid();
        shortidWinfo = reSong.getShortidWinfo();
        artist = reSong.getArtist();
        album = reSong.getAlbum();
        track = reSong.getTrack();
        title = reSong.getTitle();
        time = reSong.getTime();
        timeSignature = reSong.getTimeSignature();
        filename = reSong.getFilename();
        digitalOnly = reSong.getDigitalOnly();
        compilation = reSong.getCompilation();
        keyStart = reSong.getKeyStart();
        keyAccuracy = reSong.getKeyAccuracy();
        bpmStart = reSong.getBpmStart();
        bpmAccuracy = reSong.getBpmAccuracy();
        rating = reSong.getRating();
        dateAdded = reSong.getDateAdded();
        catalogId = reSong.getCatalogId();
        label = reSong.getLabel();
        remix = reSong.getRemix();
        numPlays = reSong.getNumPlays();
        comments = reSong.getComments();
        releaseDate = reSong.getReleaseDate();
        featuring = reSong.getFeaturing();
        keyEnd = reSong.getKeyEnd();
        disabled = reSong.getDisabled();
        bpmEnd = reSong.getBpmEnd();
        beatIntensity = reSong.getBeatIntensity();
        replayGain = reSong.getReplayGain();
        stylesBitmask = reSong.getStylesBitmask();
    }

    RESong::~RESong() {
    }

    void RESong::clear() {
        id = 0;
        songidWinfo.clear();
        songid.clear();
        shortid.clear();
        shortidWinfo.clear();
        artist.clear();
        album.clear();
        track.clear();
        title.clear();
        time.clear();
        timeSignature.clear();
        filename.clear();
        digitalOnly.clear();
        compilation.clear();
        keyStart.clear();
        keyAccuracy = 0;
        bpmStart.clear();
        bpmAccuracy = 0;
        rating = 0;
        dateAdded.clear();
        catalogId.clear();
        label.clear();
        remix.clear();
        numPlays = 0;
        comments.clear();
        releaseDate.clear();
        featuring.clear();
        keyEnd.clear();
        disabled.clear();
        bpmEnd.clear();
        beatIntensity = 0;
        replayGain.clear();
        stylesBitmask.clear();
    }

# pragma mark static methods

    void RESong::populateFields(const sql::ResultSet* rs, RESong* reSong) {
        reSong->setId(rs->getInt("id"));
        reSong->setSongidWinfo(rs->getString("songidWinfo"));
        reSong->setSongid(rs->getString("songid"));
        reSong->setShortid(rs->getString("shortid"));
        reSong->setShortidWinfo(rs->getString("shortidWinfo"));
        reSong->setArtist(rs->getString("artist"));
        reSong->setAlbum(rs->getString("album"));
        reSong->setTrack(rs->getString("track"));
        reSong->setTitle(rs->getString("title"));
        reSong->setTime(rs->getString("time"));
        reSong->setTimeSignature(rs->getString("timeSignature"));
        reSong->setFilename(rs->getString("filename"));
        reSong->setDigitalOnly(rs->getString("digitalOnly"));
        reSong->setCompilation(rs->getString("compilation"));
        reSong->setKeyStart(rs->getString("keyStart"));
        reSong->setKeyAccuracy(rs->getInt("keyAccuracy"));
        reSong->setBpmStart(rs->getString("bpmStart"));
        reSong->setBpmAccuracy(rs->getInt("bpmAccuracy"));
        reSong->setRating(rs->getInt("rating"));
        reSong->setDateAdded(rs->getString("dateAdded"));
        reSong->setCatalogId(rs->getString("catalogId"));
        reSong->setLabel(rs->getString("label"));
        reSong->setRemix(rs->getString("remix"));
        reSong->setNumPlays(rs->getInt("numPlays"));
        reSong->setComments(rs->getString("comments"));
        reSong->setReleaseDate(rs->getString("releaseDate"));
        reSong->setFeaturing(rs->getString("featuring"));
        reSong->setKeyEnd(rs->getString("keyEnd"));
        reSong->setDisabled(rs->getString("disabled"));
        reSong->setBpmEnd(rs->getString("bpmEnd"));
        reSong->setBeatIntensity(rs->getInt("beatIntensity"));
        reSong->setReplayGain(rs->getString("replayGain"));
    }

    RESong* RESong::findById(int id) {
        for (int i = 0; i < 2; ++i) {
            try {
                sql::PreparedStatement *ps = MysqlAccess::getInstance().getPreparedStatement("select RESongs.* from RESongs where RESongs.id = ?");
                ps->setInt(1, id);
                sql::ResultSet *rs = ps->executeQuery();
                RESong *reSong = NULL;
                if (rs->next()) {
                    reSong = new RESong();
                    populateFields(rs, reSong);
                }
                rs->close();
                delete rs;

                return reSong;
            } catch (sql::SQLException &e) {
                LOG(WARNING) << "ERROR: SQLException in " << __FILE__ << " (" << __func__<< ") on line " << __LINE__;
                LOG(WARNING) << "ERROR: " << e.what() << " (MySQL error code: " << e.getErrorCode() << ", SQLState: " << e.getSQLState() << ")";
                bool reconnected = MysqlAccess::getInstance().reconnect();
                LOG(INFO) << (reconnected ? "Successful" : "Failed") << " mysql reconnection";
                if (i == 1) AlertsChannel::getInstance().send(std::string("DB Error (") + __FILE__ + "::" + __func__ + ") : " + e.what());
            }
        }
    }

    RESong* RESong::findBySongid(const string& songid) {
        for (int i = 0; i < 2; ++i) {
            try {
                sql::PreparedStatement *ps = MysqlAccess::getInstance().getPreparedStatement("select RESongs.* from RESongs where RESongs.songid = ?");
                ps->setString(1, songid);
                sql::ResultSet *rs = ps->executeQuery();
                RESong *reSong = NULL;
                if (rs->next()) {
                    reSong = new RESong();
                    populateFields(rs, reSong);
                }
                rs->close();
                delete rs;

                return reSong;
            } catch (sql::SQLException &e) {
                LOG(WARNING) << "ERROR: SQLException in " << __FILE__ << " (" << __func__<< ") on line " << __LINE__;
                LOG(WARNING) << "ERROR: " << e.what() << " (MySQL error code: " << e.getErrorCode() << ", SQLState: " << e.getSQLState() << ")";
                bool reconnected = MysqlAccess::getInstance().reconnect();
                LOG(INFO) << (reconnected ? "Successful" : "Failed") << " mysql reconnection";
                if (i == 1) AlertsChannel::getInstance().send(std::string("DB Error (") + __FILE__ + "::" + __func__ + ") : " + e.what());
            }
        }
    }

    ResultSetIterator<RESong>* RESong::findAll() {
        for (int i = 0; i < 2; ++i) {
            try {
                sql::PreparedStatement *ps = MysqlAccess::getInstance().getPreparedStatement("select RESongs.* from RESongs");
                sql::ResultSet *rs = ps->executeQuery();
                ResultSetIterator<RESong> *dtrs = new ResultSetIterator<RESong>(rs);
                return dtrs;
            } catch (sql::SQLException &e) {
                LOG(WARNING) << "ERROR: SQLException in " << __FILE__ << " (" << __func__<< ") on line " << __LINE__;
                LOG(WARNING) << "ERROR: " << e.what() << " (MySQL error code: " << e.getErrorCode() << ", SQLState: " << e.getSQLState() << ")";
                bool reconnected = MysqlAccess::getInstance().reconnect();
                LOG(INFO) << (reconnected ? "Successful" : "Failed") << " mysql reconnection";
                if (i == 1) AlertsChannel::getInstance().send(std::string("DB Error (") + __FILE__ + "::" + __func__ + ") : " + e.what());
            }
        }
    }

# pragma mark persistence

    int RESong::update() {
        for (int i = 0; i < 2; ++i) {
            try {

                sql::PreparedStatement *ps = MysqlAccess::getInstance().getPreparedStatement("update RESongs set songidWinfo=?, songid=?, shortid=?, shortidWinfo=?, artist=?, album=?, track=?, title=?, time=?, timeSignature=?, filename=?, digitalOnly=?, compilation=?, keyStart=?, keyAccuracy=?, bpmStart=?, bpmAccuracy=?, rating=?, dateAdded=?, catalogId=?, label=?, remix=?, numPlays=?, comments=?, releaseDate=?, featuring=?, keyEnd=?, disabled=?, bpmEnd=?, beatIntensity=?, replayGain=? where id=?");
                if (!songidWinfo.empty()) ps->setString(1, songidWinfo);
                else ps->setNull(1, sql::DataType::VARCHAR);
                if (!songid.empty()) ps->setString(2, songid);
                else ps->setNull(2, sql::DataType::VARCHAR);
                if (!shortid.empty()) ps->setString(3, shortid);
                else ps->setNull(3, sql::DataType::VARCHAR);
                if (!shortidWinfo.empty()) ps->setString(4, shortidWinfo);
                else ps->setNull(4, sql::DataType::VARCHAR);
                if (!artist.empty()) ps->setString(5, artist);
                else ps->setNull(5, sql::DataType::VARCHAR);
                if (!album.empty()) ps->setString(6, album);
                else ps->setNull(6, sql::DataType::VARCHAR);
                if (!track.empty()) ps->setString(7, track);
                else ps->setNull(7, sql::DataType::VARCHAR);
                if (!title.empty()) ps->setString(8, title);
                else ps->setNull(8, sql::DataType::VARCHAR);
                if (!time.empty()) ps->setString(9, time);
                else ps->setNull(9, sql::DataType::VARCHAR);
                if (!timeSignature.empty()) ps->setString(10, timeSignature);
                else ps->setNull(10, sql::DataType::VARCHAR);
                if (!filename.empty()) ps->setString(11, filename);
                else ps->setNull(11, sql::DataType::VARCHAR);
                if (!digitalOnly.empty()) ps->setString(12, digitalOnly);
                else ps->setNull(12, sql::DataType::VARCHAR);
                if (!compilation.empty()) ps->setString(13, compilation);
                else ps->setNull(13, sql::DataType::VARCHAR);
                if (!keyStart.empty()) ps->setString(14, keyStart);
                else ps->setNull(14, sql::DataType::VARCHAR);
                if (keyAccuracy > 0) ps->setInt(15, keyAccuracy);
                else ps->setNull(15, sql::DataType::INTEGER);
                if (!bpmStart.empty()) ps->setString(16, bpmStart);
                else ps->setNull(16, sql::DataType::VARCHAR);
                if (bpmAccuracy > 0) ps->setInt(17, bpmAccuracy);
                else ps->setNull(17, sql::DataType::INTEGER);
                if (rating > 0) ps->setInt(18, rating);
                else ps->setNull(18, sql::DataType::INTEGER);
                if (!dateAdded.empty()) ps->setString(19, dateAdded);
                else ps->setNull(19, sql::DataType::VARCHAR);
                if (!catalogId.empty()) ps->setString(20, catalogId);
                else ps->setNull(20, sql::DataType::VARCHAR);
                if (!label.empty()) ps->setString(21, label);
                else ps->setNull(21, sql::DataType::VARCHAR);
                if (!remix.empty()) ps->setString(22, remix);
                else ps->setNull(22, sql::DataType::VARCHAR);
                if (numPlays > 0) ps->setInt(23, numPlays);
                else ps->setNull(23, sql::DataType::INTEGER);
                if (!comments.empty()) ps->setString(24, comments);
                else ps->setNull(24, sql::DataType::VARCHAR);
                if (!releaseDate.empty()) ps->setString(25, releaseDate);
                else ps->setNull(25, sql::DataType::VARCHAR);
                if (!featuring.empty()) ps->setString(26, featuring);
                else ps->setNull(26, sql::DataType::VARCHAR);
                if (!keyEnd.empty()) ps->setString(27, keyEnd);
                else ps->setNull(27, sql::DataType::VARCHAR);
                if (!disabled.empty()) ps->setString(28, disabled);
                else ps->setNull(28, sql::DataType::VARCHAR);
                if (!bpmEnd.empty()) ps->setString(29, bpmEnd);
                else ps->setNull(29, sql::DataType::VARCHAR);
                if (beatIntensity > 0) ps->setInt(30, beatIntensity);
                else ps->setNull(30, sql::DataType::INTEGER);
                if (!replayGain.empty()) ps->setString(31, replayGain);
                else ps->setNull(31, sql::DataType::VARCHAR);
                ps->setInt(32, id);
                int result = ps->executeUpdate();
                return result;
            } catch (sql::SQLException &e) {
                LOG(WARNING) << "ERROR: SQLException in " << __FILE__ << " (" << __func__<< ") on line " << __LINE__;
                LOG(WARNING) << "ERROR: " << e.what() << " (MySQL error code: " << e.getErrorCode() << ", SQLState: " << e.getSQLState() << ")";
                bool reconnected = MysqlAccess::getInstance().reconnect();
                LOG(INFO) << (reconnected ? "Successful" : "Failed") << " mysql reconnection";
                if (i == 1) AlertsChannel::getInstance().send(std::string("DB Error (") + __FILE__ + "::" + __func__ + ") : " + e.what());
            }
        }
    }

    int RESong::save() {
        for (int i = 0; i < 2; ++i) {
            try {
                if (id == 0) {
                    sql::PreparedStatement *ps = MysqlAccess::getInstance().getPreparedStatement("select max(id) from RESongs");
                    sql::ResultSet *rs = ps->executeQuery();
                    rs->next();
                    id = rs->getInt(1) + 1;
                    rs->close();
                    delete rs;
                }

                sql::PreparedStatement *ps = MysqlAccess::getInstance().getPreparedStatement("insert into RESongs (id, songidWinfo, songid, shortid, shortidWinfo, artist, album, track, title, time, timeSignature, filename, digitalOnly, compilation, keyStart, keyAccuracy, bpmStart, bpmAccuracy, rating, dateAdded, catalogId, label, remix, numPlays, comments, releaseDate, featuring, keyEnd, disabled, bpmEnd, beatIntensity, replayGain) values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)");
                if (id > 0) ps->setInt(1, id);
                else ps->setNull(1, sql::DataType::INTEGER);
                if (!songidWinfo.empty()) ps->setString(2, songidWinfo);
                else ps->setNull(2, sql::DataType::VARCHAR);
                if (!songid.empty()) ps->setString(3, songid);
                else ps->setNull(3, sql::DataType::VARCHAR);
                if (!shortid.empty()) ps->setString(4, shortid);
                else ps->setNull(4, sql::DataType::VARCHAR);
                if (!shortidWinfo.empty()) ps->setString(5, shortidWinfo);
                else ps->setNull(5, sql::DataType::VARCHAR);
                if (!artist.empty()) ps->setString(6, artist);
                else ps->setNull(6, sql::DataType::VARCHAR);
                if (!album.empty()) ps->setString(7, album);
                else ps->setNull(7, sql::DataType::VARCHAR);
                if (!track.empty()) ps->setString(8, track);
                else ps->setNull(8, sql::DataType::VARCHAR);
                if (!title.empty()) ps->setString(9, title);
                else ps->setNull(9, sql::DataType::VARCHAR);
                if (!time.empty()) ps->setString(10, time);
                else ps->setNull(10, sql::DataType::VARCHAR);
                if (!timeSignature.empty()) ps->setString(11, timeSignature);
                else ps->setNull(11, sql::DataType::VARCHAR);
                if (!filename.empty()) ps->setString(12, filename);
                else ps->setNull(12, sql::DataType::VARCHAR);
                if (!digitalOnly.empty()) ps->setString(13, digitalOnly);
                else ps->setNull(13, sql::DataType::VARCHAR);
                if (!compilation.empty()) ps->setString(14, compilation);
                else ps->setNull(14, sql::DataType::VARCHAR);
                if (!keyStart.empty()) ps->setString(15, keyStart);
                else ps->setNull(15, sql::DataType::VARCHAR);
                if (keyAccuracy > 0) ps->setInt(16, keyAccuracy);
                else ps->setNull(16, sql::DataType::INTEGER);
                if (!bpmStart.empty()) ps->setString(17, bpmStart);
                else ps->setNull(17, sql::DataType::VARCHAR);
                if (bpmAccuracy > 0) ps->setInt(18, bpmAccuracy);
                else ps->setNull(18, sql::DataType::INTEGER);
                if (rating > 0) ps->setInt(19, rating);
                else ps->setNull(19, sql::DataType::INTEGER);
                if (!dateAdded.empty()) ps->setString(20, dateAdded);
                else ps->setNull(20, sql::DataType::VARCHAR);
                if (!catalogId.empty()) ps->setString(21, catalogId);
                else ps->setNull(21, sql::DataType::VARCHAR);
                if (!label.empty()) ps->setString(22, label);
                else ps->setNull(22, sql::DataType::VARCHAR);
                if (!remix.empty()) ps->setString(23, remix);
                else ps->setNull(23, sql::DataType::VARCHAR);
                if (numPlays > 0) ps->setInt(24, numPlays);
                else ps->setNull(24, sql::DataType::INTEGER);
                if (!comments.empty()) ps->setString(25, comments);
                else ps->setNull(25, sql::DataType::VARCHAR);
                if (!releaseDate.empty()) ps->setString(26, releaseDate);
                else ps->setNull(26, sql::DataType::VARCHAR);
                if (!featuring.empty()) ps->setString(27, featuring);
                else ps->setNull(27, sql::DataType::VARCHAR);
                if (!keyEnd.empty()) ps->setString(28, keyEnd);
                else ps->setNull(28, sql::DataType::VARCHAR);
                if (!disabled.empty()) ps->setString(29, disabled);
                else ps->setNull(29, sql::DataType::VARCHAR);
                if (!bpmEnd.empty()) ps->setString(30, bpmEnd);
                else ps->setNull(30, sql::DataType::VARCHAR);
                if (beatIntensity > 0) ps->setInt(31, beatIntensity);
                else ps->setNull(31, sql::DataType::INTEGER);
                if (!replayGain.empty()) ps->setString(32, replayGain);
                else ps->setNull(32, sql::DataType::VARCHAR);
                int saved = ps->executeUpdate();
                if (!saved) {
                    LOG(WARNING) << "Not able to save reSong";
                    return saved;
                } else {
                    return saved;
                }
            } catch (sql::SQLException &e) {
                LOG(WARNING) << "ERROR: SQLException in " << __FILE__ << " (" << __func__<< ") on line " << __LINE__;
                LOG(WARNING) << "ERROR: " << e.what() << " (MySQL error code: " << e.getErrorCode() << ", SQLState: " << e.getSQLState() << ")";
                bool reconnected = MysqlAccess::getInstance().reconnect();
                LOG(INFO) << (reconnected ? "Successful" : "Failed") << " mysql reconnection";
                if (i == 1) AlertsChannel::getInstance().send(std::string("DB Error (") + __FILE__ + "::" + __func__ + ") : " + e.what());
            }
        }
    }

    bool RESong::sync() {
        RESong* reSong = findById(id);
        if (!reSong) return true;

        // check fields
        bool needsUpdate = false;
        boost::regex decimal("(-?\\d+)\\.?\\d*");
        boost::smatch match1;
        boost::smatch match2;
        if (id != reSong->getId()) {
            if (id) {
                LOG(INFO) << "updating reSong " << id << " id from " << reSong->getId() << " to " << id;
                needsUpdate = true;
            } else {
                id = reSong->getId();
            }
        }
        if (songidWinfo.compare(reSong->getSongidWinfo())  && (!boost::regex_match(songidWinfo, match1, decimal) || !boost::regex_match(reSong->getSongidWinfo(), match2, decimal) || match1[1].str().compare(match2[1].str()))) {
            if (!songidWinfo.empty()) {
                LOG(INFO) << "updating reSong " << id << " songidWinfo from " << reSong->getSongidWinfo() << " to " << songidWinfo;
                needsUpdate = true;
            } else {
                songidWinfo = reSong->getSongidWinfo();
            }
        }
        if (songid.compare(reSong->getSongid())  && (!boost::regex_match(songid, match1, decimal) || !boost::regex_match(reSong->getSongid(), match2, decimal) || match1[1].str().compare(match2[1].str()))) {
            if (!songid.empty()) {
                LOG(INFO) << "updating reSong " << id << " songid from " << reSong->getSongid() << " to " << songid;
                needsUpdate = true;
            } else {
                songid = reSong->getSongid();
            }
        }
        if (shortid.compare(reSong->getShortid())  && (!boost::regex_match(shortid, match1, decimal) || !boost::regex_match(reSong->getShortid(), match2, decimal) || match1[1].str().compare(match2[1].str()))) {
            if (!shortid.empty()) {
                LOG(INFO) << "updating reSong " << id << " shortid from " << reSong->getShortid() << " to " << shortid;
                needsUpdate = true;
            } else {
                shortid = reSong->getShortid();
            }
        }
        if (shortidWinfo.compare(reSong->getShortidWinfo())  && (!boost::regex_match(shortidWinfo, match1, decimal) || !boost::regex_match(reSong->getShortidWinfo(), match2, decimal) || match1[1].str().compare(match2[1].str()))) {
            if (!shortidWinfo.empty()) {
                LOG(INFO) << "updating reSong " << id << " shortidWinfo from " << reSong->getShortidWinfo() << " to " << shortidWinfo;
                needsUpdate = true;
            } else {
                shortidWinfo = reSong->getShortidWinfo();
            }
        }
        if (artist.compare(reSong->getArtist())  && (!boost::regex_match(artist, match1, decimal) || !boost::regex_match(reSong->getArtist(), match2, decimal) || match1[1].str().compare(match2[1].str()))) {
            if (!artist.empty()) {
                LOG(INFO) << "updating reSong " << id << " artist from " << reSong->getArtist() << " to " << artist;
                needsUpdate = true;
            } else {
                artist = reSong->getArtist();
            }
        }
        if (album.compare(reSong->getAlbum())  && (!boost::regex_match(album, match1, decimal) || !boost::regex_match(reSong->getAlbum(), match2, decimal) || match1[1].str().compare(match2[1].str()))) {
            if (!album.empty()) {
                LOG(INFO) << "updating reSong " << id << " album from " << reSong->getAlbum() << " to " << album;
                needsUpdate = true;
            } else {
                album = reSong->getAlbum();
            }
        }
        if (track.compare(reSong->getTrack())  && (!boost::regex_match(track, match1, decimal) || !boost::regex_match(reSong->getTrack(), match2, decimal) || match1[1].str().compare(match2[1].str()))) {
            if (!track.empty()) {
                LOG(INFO) << "updating reSong " << id << " track from " << reSong->getTrack() << " to " << track;
                needsUpdate = true;
            } else {
                track = reSong->getTrack();
            }
        }
        if (title.compare(reSong->getTitle())  && (!boost::regex_match(title, match1, decimal) || !boost::regex_match(reSong->getTitle(), match2, decimal) || match1[1].str().compare(match2[1].str()))) {
            if (!title.empty()) {
                LOG(INFO) << "updating reSong " << id << " title from " << reSong->getTitle() << " to " << title;
                needsUpdate = true;
            } else {
                title = reSong->getTitle();
            }
        }
        if (time.compare(reSong->getTime())  && (!boost::regex_match(time, match1, decimal) || !boost::regex_match(reSong->getTime(), match2, decimal) || match1[1].str().compare(match2[1].str()))) {
            if (!time.empty()) {
                LOG(INFO) << "updating reSong " << id << " time from " << reSong->getTime() << " to " << time;
                needsUpdate = true;
            } else {
                time = reSong->getTime();
            }
        }
        if (timeSignature.compare(reSong->getTimeSignature())  && (!boost::regex_match(timeSignature, match1, decimal) || !boost::regex_match(reSong->getTimeSignature(), match2, decimal) || match1[1].str().compare(match2[1].str()))) {
            if (!timeSignature.empty()) {
                LOG(INFO) << "updating reSong " << id << " timeSignature from " << reSong->getTimeSignature() << " to " << timeSignature;
                needsUpdate = true;
            } else {
                timeSignature = reSong->getTimeSignature();
            }
        }
        if (filename.compare(reSong->getFilename())  && (!boost::regex_match(filename, match1, decimal) || !boost::regex_match(reSong->getFilename(), match2, decimal) || match1[1].str().compare(match2[1].str()))) {
            if (!filename.empty()) {
                LOG(INFO) << "updating reSong " << id << " filename from " << reSong->getFilename() << " to " << filename;
                needsUpdate = true;
            } else {
                filename = reSong->getFilename();
            }
        }
        if (digitalOnly.compare(reSong->getDigitalOnly())  && (!boost::regex_match(digitalOnly, match1, decimal) || !boost::regex_match(reSong->getDigitalOnly(), match2, decimal) || match1[1].str().compare(match2[1].str()))) {
            if (!digitalOnly.empty()) {
                LOG(INFO) << "updating reSong " << id << " digitalOnly from " << reSong->getDigitalOnly() << " to " << digitalOnly;
                needsUpdate = true;
            } else {
                digitalOnly = reSong->getDigitalOnly();
            }
        }
        if (compilation.compare(reSong->getCompilation())  && (!boost::regex_match(compilation, match1, decimal) || !boost::regex_match(reSong->getCompilation(), match2, decimal) || match1[1].str().compare(match2[1].str()))) {
            if (!compilation.empty()) {
                LOG(INFO) << "updating reSong " << id << " compilation from " << reSong->getCompilation() << " to " << compilation;
                needsUpdate = true;
            } else {
                compilation = reSong->getCompilation();
            }
        }
        if (keyStart.compare(reSong->getKeyStart())  && (!boost::regex_match(keyStart, match1, decimal) || !boost::regex_match(reSong->getKeyStart(), match2, decimal) || match1[1].str().compare(match2[1].str()))) {
            if (!keyStart.empty()) {
                LOG(INFO) << "updating reSong " << id << " keyStart from " << reSong->getKeyStart() << " to " << keyStart;
                needsUpdate = true;
            } else {
                keyStart = reSong->getKeyStart();
            }
        }
        if (keyAccuracy != reSong->getKeyAccuracy()) {
            if (keyAccuracy) {
                LOG(INFO) << "updating reSong " << id << " keyAccuracy from " << reSong->getKeyAccuracy() << " to " << keyAccuracy;
                needsUpdate = true;
            } else {
                keyAccuracy = reSong->getKeyAccuracy();
            }
        }
        if (bpmStart.compare(reSong->getBpmStart())  && (!boost::regex_match(bpmStart, match1, decimal) || !boost::regex_match(reSong->getBpmStart(), match2, decimal) || match1[1].str().compare(match2[1].str()))) {
            if (!bpmStart.empty()) {
                LOG(INFO) << "updating reSong " << id << " bpmStart from " << reSong->getBpmStart() << " to " << bpmStart;
                needsUpdate = true;
            } else {
                bpmStart = reSong->getBpmStart();
            }
        }
        if (bpmAccuracy != reSong->getBpmAccuracy()) {
            if (bpmAccuracy) {
                LOG(INFO) << "updating reSong " << id << " bpmAccuracy from " << reSong->getBpmAccuracy() << " to " << bpmAccuracy;
                needsUpdate = true;
            } else {
                bpmAccuracy = reSong->getBpmAccuracy();
            }
        }
        if (rating != reSong->getRating()) {
            if (rating) {
                LOG(INFO) << "updating reSong " << id << " rating from " << reSong->getRating() << " to " << rating;
                needsUpdate = true;
            } else {
                rating = reSong->getRating();
            }
        }
        if (dateAdded.compare(reSong->getDateAdded())  && (!boost::regex_match(dateAdded, match1, decimal) || !boost::regex_match(reSong->getDateAdded(), match2, decimal) || match1[1].str().compare(match2[1].str()))) {
            if (!dateAdded.empty()) {
                LOG(INFO) << "updating reSong " << id << " dateAdded from " << reSong->getDateAdded() << " to " << dateAdded;
                needsUpdate = true;
            } else {
                dateAdded = reSong->getDateAdded();
            }
        }
        if (catalogId.compare(reSong->getCatalogId())  && (!boost::regex_match(catalogId, match1, decimal) || !boost::regex_match(reSong->getCatalogId(), match2, decimal) || match1[1].str().compare(match2[1].str()))) {
            if (!catalogId.empty()) {
                LOG(INFO) << "updating reSong " << id << " catalogId from " << reSong->getCatalogId() << " to " << catalogId;
                needsUpdate = true;
            } else {
                catalogId = reSong->getCatalogId();
            }
        }
        if (label.compare(reSong->getLabel())  && (!boost::regex_match(label, match1, decimal) || !boost::regex_match(reSong->getLabel(), match2, decimal) || match1[1].str().compare(match2[1].str()))) {
            if (!label.empty()) {
                LOG(INFO) << "updating reSong " << id << " label from " << reSong->getLabel() << " to " << label;
                needsUpdate = true;
            } else {
                label = reSong->getLabel();
            }
        }
        if (remix.compare(reSong->getRemix())  && (!boost::regex_match(remix, match1, decimal) || !boost::regex_match(reSong->getRemix(), match2, decimal) || match1[1].str().compare(match2[1].str()))) {
            if (!remix.empty()) {
                LOG(INFO) << "updating reSong " << id << " remix from " << reSong->getRemix() << " to " << remix;
                needsUpdate = true;
            } else {
                remix = reSong->getRemix();
            }
        }
        if (numPlays != reSong->getNumPlays()) {
            if (numPlays) {
                LOG(INFO) << "updating reSong " << id << " numPlays from " << reSong->getNumPlays() << " to " << numPlays;
                needsUpdate = true;
            } else {
                numPlays = reSong->getNumPlays();
            }
        }
        if (comments.compare(reSong->getComments())  && (!boost::regex_match(comments, match1, decimal) || !boost::regex_match(reSong->getComments(), match2, decimal) || match1[1].str().compare(match2[1].str()))) {
            if (!comments.empty()) {
                LOG(INFO) << "updating reSong " << id << " comments from " << reSong->getComments() << " to " << comments;
                needsUpdate = true;
            } else {
                comments = reSong->getComments();
            }
        }
        if (releaseDate.compare(reSong->getReleaseDate())  && (!boost::regex_match(releaseDate, match1, decimal) || !boost::regex_match(reSong->getReleaseDate(), match2, decimal) || match1[1].str().compare(match2[1].str()))) {
            if (!releaseDate.empty()) {
                LOG(INFO) << "updating reSong " << id << " releaseDate from " << reSong->getReleaseDate() << " to " << releaseDate;
                needsUpdate = true;
            } else {
                releaseDate = reSong->getReleaseDate();
            }
        }
        if (featuring.compare(reSong->getFeaturing())  && (!boost::regex_match(featuring, match1, decimal) || !boost::regex_match(reSong->getFeaturing(), match2, decimal) || match1[1].str().compare(match2[1].str()))) {
            if (!featuring.empty()) {
                LOG(INFO) << "updating reSong " << id << " featuring from " << reSong->getFeaturing() << " to " << featuring;
                needsUpdate = true;
            } else {
                featuring = reSong->getFeaturing();
            }
        }
        if (keyEnd.compare(reSong->getKeyEnd())  && (!boost::regex_match(keyEnd, match1, decimal) || !boost::regex_match(reSong->getKeyEnd(), match2, decimal) || match1[1].str().compare(match2[1].str()))) {
            if (!keyEnd.empty()) {
                LOG(INFO) << "updating reSong " << id << " keyEnd from " << reSong->getKeyEnd() << " to " << keyEnd;
                needsUpdate = true;
            } else {
                keyEnd = reSong->getKeyEnd();
            }
        }
        if (disabled.compare(reSong->getDisabled())  && (!boost::regex_match(disabled, match1, decimal) || !boost::regex_match(reSong->getDisabled(), match2, decimal) || match1[1].str().compare(match2[1].str()))) {
            if (!disabled.empty()) {
                LOG(INFO) << "updating reSong " << id << " disabled from " << reSong->getDisabled() << " to " << disabled;
                needsUpdate = true;
            } else {
                disabled = reSong->getDisabled();
            }
        }
        if (bpmEnd.compare(reSong->getBpmEnd())  && (!boost::regex_match(bpmEnd, match1, decimal) || !boost::regex_match(reSong->getBpmEnd(), match2, decimal) || match1[1].str().compare(match2[1].str()))) {
            if (!bpmEnd.empty()) {
                LOG(INFO) << "updating reSong " << id << " bpmEnd from " << reSong->getBpmEnd() << " to " << bpmEnd;
                needsUpdate = true;
            } else {
                bpmEnd = reSong->getBpmEnd();
            }
        }
        if (beatIntensity != reSong->getBeatIntensity()) {
            if (beatIntensity) {
                LOG(INFO) << "updating reSong " << id << " beatIntensity from " << reSong->getBeatIntensity() << " to " << beatIntensity;
                needsUpdate = true;
            } else {
                beatIntensity = reSong->getBeatIntensity();
            }
        }
        if (replayGain.compare(reSong->getReplayGain())  && (!boost::regex_match(replayGain, match1, decimal) || !boost::regex_match(reSong->getReplayGain(), match2, decimal) || match1[1].str().compare(match2[1].str()))) {
            if (!replayGain.empty()) {
                LOG(INFO) << "updating reSong " << id << " replayGain from " << reSong->getReplayGain() << " to " << replayGain;
                needsUpdate = true;
            } else {
                replayGain = reSong->getReplayGain();
            }
        }
        return needsUpdate;
    }


# pragma mark accessors

    int RESong::getId() const { return id; }
    void RESong::setId(const int id) { this->id = id; }

    const string& RESong::getSongidWinfo() const { return songidWinfo; }
    void RESong::setSongidWinfo(const string& songidWinfo) { this->songidWinfo = songidWinfo; }

    const string& RESong::getSongid() const { return songid; }
    void RESong::setSongid(const string& songid) { this->songid = songid; }

    const string& RESong::getShortid() const { return shortid; }
    void RESong::setShortid(const string& shortid) { this->shortid = shortid; }

    const string& RESong::getShortidWinfo() const { return shortidWinfo; }
    void RESong::setShortidWinfo(const string& shortidWinfo) { this->shortidWinfo = shortidWinfo; }

    const string& RESong::getArtist() const { return artist; }
    void RESong::setArtist(const string& artist) { this->artist = artist; }

    const string& RESong::getAlbum() const { return album; }
    void RESong::setAlbum(const string& album) { this->album = album; }

    const string& RESong::getTrack() const { return track; }
    void RESong::setTrack(const string& track) { this->track = track; }

    const string& RESong::getTitle() const { return title; }
    void RESong::setTitle(const string& title) { this->title = title; }

    const string& RESong::getTime() const { return time; }
    void RESong::setTime(const string& time) { this->time = time; }

    const string& RESong::getTimeSignature() const { return timeSignature; }
    void RESong::setTimeSignature(const string& timeSignature) { this->timeSignature = timeSignature; }

    const string& RESong::getFilename() const { return filename; }
    void RESong::setFilename(const string& filename) { this->filename = filename; }

    const string& RESong::getDigitalOnly() const { return digitalOnly; }
    void RESong::setDigitalOnly(const string& digitalOnly) { this->digitalOnly = digitalOnly; }

    const string& RESong::getCompilation() const { return compilation; }
    void RESong::setCompilation(const string& compilation) { this->compilation = compilation; }

    const string& RESong::getKeyStart() const { return keyStart; }
    void RESong::setKeyStart(const string& keyStart) { this->keyStart = keyStart; }

    int RESong::getKeyAccuracy() const { return keyAccuracy; }
    void RESong::setKeyAccuracy(const int keyAccuracy) { this->keyAccuracy = keyAccuracy; }

    const string& RESong::getBpmStart() const { return bpmStart; }
    void RESong::setBpmStart(const string& bpmStart) { this->bpmStart = bpmStart; }

    int RESong::getBpmAccuracy() const { return bpmAccuracy; }
    void RESong::setBpmAccuracy(const int bpmAccuracy) { this->bpmAccuracy = bpmAccuracy; }

    int RESong::getRating() const { return rating; }
    void RESong::setRating(const int rating) { this->rating = rating; }

    const string& RESong::getDateAdded() const { return dateAdded; }
    void RESong::setDateAdded(const string& dateAdded) { this->dateAdded = dateAdded; }

    const string& RESong::getCatalogId() const { return catalogId; }
    void RESong::setCatalogId(const string& catalogId) { this->catalogId = catalogId; }

    const string& RESong::getLabel() const { return label; }
    void RESong::setLabel(const string& label) { this->label = label; }

    const string& RESong::getRemix() const { return remix; }
    void RESong::setRemix(const string& remix) { this->remix = remix; }

    int RESong::getNumPlays() const { return numPlays; }
    void RESong::setNumPlays(const int numPlays) { this->numPlays = numPlays; }

    const string& RESong::getComments() const { return comments; }
    void RESong::setComments(const string& comments) { this->comments = comments; }

    const string& RESong::getReleaseDate() const { return releaseDate; }
    void RESong::setReleaseDate(const string& releaseDate) { this->releaseDate = releaseDate; }

    const string& RESong::getFeaturing() const { return featuring; }
    void RESong::setFeaturing(const string& featuring) { this->featuring = featuring; }

    const string& RESong::getKeyEnd() const { return keyEnd; }
    void RESong::setKeyEnd(const string& keyEnd) { this->keyEnd = keyEnd; }

    const string& RESong::getDisabled() const { return disabled; }
    void RESong::setDisabled(const string& disabled) { this->disabled = disabled; }

    const string& RESong::getBpmEnd() const { return bpmEnd; }
    void RESong::setBpmEnd(const string& bpmEnd) { this->bpmEnd = bpmEnd; }

    int RESong::getBeatIntensity() const { return beatIntensity; }
    void RESong::setBeatIntensity(const int beatIntensity) { this->beatIntensity = beatIntensity; }

    const string& RESong::getReplayGain() const { return replayGain; }
    void RESong::setReplayGain(const string& replayGain) { this->replayGain = replayGain; }

    const string& RESong::getStylesBitmask() const { return stylesBitmask; }
    void RESong::setStylesBitmask(const string& stylesBitmask) { this->stylesBitmask = stylesBitmask; }

}
}
