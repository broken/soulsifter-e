//
//  RESong.cpp
//  soul-sifter
//
//  Created by Robby Neale
//  Generated by generate_model.rb
//

#include "RESong.h"

#include <cmath>
#include <string>
#include <sstream>

#include <boost/regex.hpp>
#include <boost/algorithm/string.hpp>
#include <jdbc/cppconn/connection.h>
#include <jdbc/cppconn/statement.h>
#include <jdbc/cppconn/prepared_statement.h>
#include <jdbc/cppconn/resultset.h>
#include <jdbc/cppconn/exception.h>
#include <jdbc/cppconn/warning.h>
#include <g3log/g3log.hpp>

#include "AlertsChannel.h"
#include "MysqlAccess.h"
#include "DTVectorUtil.h"

using namespace std;

namespace dogatech {
namespace soulsifter {

# pragma mark initialization

    RESong::RESong() :
    id(0),
    songidWinfo(),
    songid(),
    shortid(),
    shortidWinfo(),
    artist(),
    album(),
    track(),
    title(),
    time(),
    timeSignature(),
    filename(),
    digitalOnly(),
    compilation(),
    keyStart(),
    keyAccuracy(0),
    bpmStart(),
    bpmAccuracy(0),
    rating(0),
    dateAdded(),
    catalogId(),
    label(),
    remix(),
    numPlays(0),
    comments(),
    releaseDate(),
    featuring(),
    keyEnd(),
    disabled(),
    bpmEnd(),
    beatIntensity(0),
    replayGain(),
    stylesBitmask() {
    }

    RESong::RESong(const RESong& reSong) :
    id(reSong.getId()),
    songidWinfo(reSong.getSongidWinfo()),
    songid(reSong.getSongid()),
    shortid(reSong.getShortid()),
    shortidWinfo(reSong.getShortidWinfo()),
    artist(reSong.getArtist()),
    album(reSong.getAlbum()),
    track(reSong.getTrack()),
    title(reSong.getTitle()),
    time(reSong.getTime()),
    timeSignature(reSong.getTimeSignature()),
    filename(reSong.getFilename()),
    digitalOnly(reSong.getDigitalOnly()),
    compilation(reSong.getCompilation()),
    keyStart(reSong.getKeyStart()),
    keyAccuracy(reSong.getKeyAccuracy()),
    bpmStart(reSong.getBpmStart()),
    bpmAccuracy(reSong.getBpmAccuracy()),
    rating(reSong.getRating()),
    dateAdded(reSong.getDateAdded()),
    catalogId(reSong.getCatalogId()),
    label(reSong.getLabel()),
    remix(reSong.getRemix()),
    numPlays(reSong.getNumPlays()),
    comments(reSong.getComments()),
    releaseDate(reSong.getReleaseDate()),
    featuring(reSong.getFeaturing()),
    keyEnd(reSong.getKeyEnd()),
    disabled(reSong.getDisabled()),
    bpmEnd(reSong.getBpmEnd()),
    beatIntensity(reSong.getBeatIntensity()),
    replayGain(reSong.getReplayGain()),
    stylesBitmask(reSong.getStylesBitmask()) {
    }

    void RESong::operator=(const RESong& reSong) {
        id = reSong.getId();
        songidWinfo = reSong.getSongidWinfo();
        songid = reSong.getSongid();
        shortid = reSong.getShortid();
        shortidWinfo = reSong.getShortidWinfo();
        artist = reSong.getArtist();
        album = reSong.getAlbum();
        track = reSong.getTrack();
        title = reSong.getTitle();
        time = reSong.getTime();
        timeSignature = reSong.getTimeSignature();
        filename = reSong.getFilename();
        digitalOnly = reSong.getDigitalOnly();
        compilation = reSong.getCompilation();
        keyStart = reSong.getKeyStart();
        keyAccuracy = reSong.getKeyAccuracy();
        bpmStart = reSong.getBpmStart();
        bpmAccuracy = reSong.getBpmAccuracy();
        rating = reSong.getRating();
        dateAdded = reSong.getDateAdded();
        catalogId = reSong.getCatalogId();
        label = reSong.getLabel();
        remix = reSong.getRemix();
        numPlays = reSong.getNumPlays();
        comments = reSong.getComments();
        releaseDate = reSong.getReleaseDate();
        featuring = reSong.getFeaturing();
        keyEnd = reSong.getKeyEnd();
        disabled = reSong.getDisabled();
        bpmEnd = reSong.getBpmEnd();
        beatIntensity = reSong.getBeatIntensity();
        replayGain = reSong.getReplayGain();
        stylesBitmask = reSong.getStylesBitmask();
    }

    RESong::~RESong() {
    }

    void RESong::clear() {
        id = 0;
        songidWinfo.clear();
        songid.clear();
        shortid.clear();
        shortidWinfo.clear();
        artist.clear();
        album.clear();
        track.clear();
        title.clear();
        time.clear();
        timeSignature.clear();
        filename.clear();
        digitalOnly.clear();
        compilation.clear();
        keyStart.clear();
        keyAccuracy = 0;
        bpmStart.clear();
        bpmAccuracy = 0;
        rating = 0;
        dateAdded.clear();
        catalogId.clear();
        label.clear();
        remix.clear();
        numPlays = 0;
        comments.clear();
        releaseDate.clear();
        featuring.clear();
        keyEnd.clear();
        disabled.clear();
        bpmEnd.clear();
        beatIntensity = 0;
        replayGain.clear();
        stylesBitmask.clear();
    }

# pragma mark static methods

    void RESong::populateFields(const sql::ResultSet* rs, RESong* reSong) {
        reSong->setId(rs->getInt("id"));
        reSong->setSongidWinfo(rs->getString("songidWinfo"));
        reSong->setSongid(rs->getString("songid"));
        reSong->setShortid(rs->getString("shortid"));
        reSong->setShortidWinfo(rs->getString("shortidWinfo"));
        reSong->setArtist(rs->getString("artist"));
        reSong->setAlbum(rs->getString("album"));
        reSong->setTrack(rs->getString("track"));
        reSong->setTitle(rs->getString("title"));
        reSong->setTime(rs->getString("time"));
        reSong->setTimeSignature(rs->getString("timeSignature"));
        reSong->setFilename(rs->getString("filename"));
        reSong->setDigitalOnly(rs->getString("digitalOnly"));
        reSong->setCompilation(rs->getString("compilation"));
        reSong->setKeyStart(rs->getString("keyStart"));
        reSong->setKeyAccuracy(rs->getInt("keyAccuracy"));
        reSong->setBpmStart(rs->getString("bpmStart"));
        reSong->setBpmAccuracy(rs->getInt("bpmAccuracy"));
        reSong->setRating(rs->getInt("rating"));
        reSong->setDateAdded(rs->getString("dateAdded"));
        reSong->setCatalogId(rs->getString("catalogId"));
        reSong->setLabel(rs->getString("label"));
        reSong->setRemix(rs->getString("remix"));
        reSong->setNumPlays(rs->getInt("numPlays"));
        reSong->setComments(rs->getString("comments"));
        reSong->setReleaseDate(rs->getString("releaseDate"));
        reSong->setFeaturing(rs->getString("featuring"));
        reSong->setKeyEnd(rs->getString("keyEnd"));
        reSong->setDisabled(rs->getString("disabled"));
        reSong->setBpmEnd(rs->getString("bpmEnd"));
        reSong->setBeatIntensity(rs->getInt("beatIntensity"));
        reSong->setReplayGain(rs->getString("replayGain"));
    }

    RESong* RESong::findById(int id) {
        for (int i = 0; i < 2; ++i) {
            try {
                sql::PreparedStatement *ps = MysqlAccess::getInstance().getPreparedStatement("select RESongs.* from RESongs where RESongs.id = ?");
                ps->setInt(1, id);
                sql::ResultSet *rs = ps->executeQuery();
                RESong *reSong = NULL;
                if (rs->next()) {
                    reSong = new RESong();
                    populateFields(rs, reSong);
                }
                rs->close();
                delete rs;

                return reSong;
            } catch (sql::SQLException &e) {
                LOG(WARNING) << "ERROR: SQLException in " << __FILE__ << " (" << __func__<< ") on line " << __LINE__;
                LOG(WARNING) << "ERROR: " << e.what() << " (MySQL error code: " << e.getErrorCode() << ", SQLState: " << e.getSQLState() << ")";
                bool reconnected = MysqlAccess::getInstance().reconnect();
                LOG(INFO) << (reconnected ? "Successful" : "Failed") << " mysql reconnection";
                if (i == 1) AlertsChannel::getInstance().send(std::string("DB Error (") + __FILE__ + "::" + __func__ + ") : " + e.what());
            }
        }
        return NULL;
    }

    RESong* RESong::findBySongid(const string& songid) {
        for (int i = 0; i < 2; ++i) {
            try {
                sql::PreparedStatement *ps = MysqlAccess::getInstance().getPreparedStatement("select RESongs.* from RESongs where RESongs.songid = ?");
                ps->setString(1, songid);
                sql::ResultSet *rs = ps->executeQuery();
                RESong *reSong = NULL;
                if (rs->next()) {
                    reSong = new RESong();
                    populateFields(rs, reSong);
                }
                rs->close();
                delete rs;

                return reSong;
            } catch (sql::SQLException &e) {
                LOG(WARNING) << "ERROR: SQLException in " << __FILE__ << " (" << __func__<< ") on line " << __LINE__;
                LOG(WARNING) << "ERROR: " << e.what() << " (MySQL error code: " << e.getErrorCode() << ", SQLState: " << e.getSQLState() << ")";
                bool reconnected = MysqlAccess::getInstance().reconnect();
                LOG(INFO) << (reconnected ? "Successful" : "Failed") << " mysql reconnection";
                if (i == 1) AlertsChannel::getInstance().send(std::string("DB Error (") + __FILE__ + "::" + __func__ + ") : " + e.what());
            }
        }
        return NULL;
    }

    ResultSetIterator<RESong>* RESong::findAll() {
        for (int i = 0; i < 2; ++i) {
            try {
                sql::PreparedStatement *ps = MysqlAccess::getInstance().getPreparedStatement("select RESongs.* from RESongs");
                sql::ResultSet *rs = ps->executeQuery();
                ResultSetIterator<RESong> *dtrs = new ResultSetIterator<RESong>(rs);
                return dtrs;
            } catch (sql::SQLException &e) {
                LOG(WARNING) << "ERROR: SQLException in " << __FILE__ << " (" << __func__<< ") on line " << __LINE__;
                LOG(WARNING) << "ERROR: " << e.what() << " (MySQL error code: " << e.getErrorCode() << ", SQLState: " << e.getSQLState() << ")";
                bool reconnected = MysqlAccess::getInstance().reconnect();
                LOG(INFO) << (reconnected ? "Successful" : "Failed") << " mysql reconnection";
                if (i == 1) AlertsChannel::getInstance().send(std::string("DB Error (") + __FILE__ + "::" + __func__ + ") : " + e.what());
            }
        }
        return NULL;
    }

# pragma mark persistence

    int RESong::update() {
        for (int i = 0; i < 2; ++i) {
            try {

                sql::PreparedStatement *ps = MysqlAccess::getInstance().getPreparedStatement("update RESongs set songidWinfo=?, songid=?, shortid=?, shortidWinfo=?, artist=?, album=?, track=?, title=?, time=?, timeSignature=?, filename=?, digitalOnly=?, compilation=?, keyStart=?, keyAccuracy=?, bpmStart=?, bpmAccuracy=?, rating=?, dateAdded=?, catalogId=?, label=?, remix=?, numPlays=?, comments=?, releaseDate=?, featuring=?, keyEnd=?, disabled=?, bpmEnd=?, beatIntensity=?, replayGain=? where id=?");
                if (!songidWinfo.empty()) ps->setString(1, songidWinfo);
                else ps->setNull(1, sql::DataType::VARCHAR);
                if (!songid.empty()) ps->setString(2, songid);
                else ps->setNull(2, sql::DataType::VARCHAR);
                if (!shortid.empty()) ps->setString(3, shortid);
                else ps->setNull(3, sql::DataType::VARCHAR);
                if (!shortidWinfo.empty()) ps->setString(4, shortidWinfo);
                else ps->setNull(4, sql::DataType::VARCHAR);
                if (!artist.empty()) ps->setString(5, artist);
                else ps->setNull(5, sql::DataType::VARCHAR);
                if (!album.empty()) ps->setString(6, album);
                else ps->setNull(6, sql::DataType::VARCHAR);
                if (!track.empty()) ps->setString(7, track);
                else ps->setNull(7, sql::DataType::VARCHAR);
                if (!title.empty()) ps->setString(8, title);
                else ps->setNull(8, sql::DataType::VARCHAR);
                if (!time.empty()) ps->setString(9, time);
                else ps->setNull(9, sql::DataType::VARCHAR);
                if (!timeSignature.empty()) ps->setString(10, timeSignature);
                else ps->setNull(10, sql::DataType::VARCHAR);
                if (!filename.empty()) ps->setString(11, filename);
                else ps->setNull(11, sql::DataType::VARCHAR);
                if (!digitalOnly.empty()) ps->setString(12, digitalOnly);
                else ps->setNull(12, sql::DataType::VARCHAR);
                if (!compilation.empty()) ps->setString(13, compilation);
                else ps->setNull(13, sql::DataType::VARCHAR);
                if (!keyStart.empty()) ps->setString(14, keyStart);
                else ps->setNull(14, sql::DataType::VARCHAR);
                if (keyAccuracy > 0) ps->setInt(15, keyAccuracy);
                else ps->setNull(15, sql::DataType::INTEGER);
                if (!bpmStart.empty()) ps->setString(16, bpmStart);
                else ps->setNull(16, sql::DataType::VARCHAR);
                if (bpmAccuracy > 0) ps->setInt(17, bpmAccuracy);
                else ps->setNull(17, sql::DataType::INTEGER);
                if (rating > 0) ps->setInt(18, rating);
                else ps->setNull(18, sql::DataType::INTEGER);
                if (!dateAdded.empty()) ps->setString(19, dateAdded);
                else ps->setNull(19, sql::DataType::VARCHAR);
                if (!catalogId.empty()) ps->setString(20, catalogId);
                else ps->setNull(20, sql::DataType::VARCHAR);
                if (!label.empty()) ps->setString(21, label);
                else ps->setNull(21, sql::DataType::VARCHAR);
                if (!remix.empty()) ps->setString(22, remix);
                else ps->setNull(22, sql::DataType::VARCHAR);
                if (numPlays > 0) ps->setInt(23, numPlays);
                else ps->setNull(23, sql::DataType::INTEGER);
                if (!comments.empty()) ps->setString(24, comments);
                else ps->setNull(24, sql::DataType::VARCHAR);
                if (!releaseDate.empty()) ps->setString(25, releaseDate);
                else ps->setNull(25, sql::DataType::VARCHAR);
                if (!featuring.empty()) ps->setString(26, featuring);
                else ps->setNull(26, sql::DataType::VARCHAR);
                if (!keyEnd.empty()) ps->setString(27, keyEnd);
                else ps->setNull(27, sql::DataType::VARCHAR);
                if (!disabled.empty()) ps->setString(28, disabled);
                else ps->setNull(28, sql::DataType::VARCHAR);
                if (!bpmEnd.empty()) ps->setString(29, bpmEnd);
                else ps->setNull(29, sql::DataType::VARCHAR);
                if (beatIntensity > 0) ps->setInt(30, beatIntensity);
                else ps->setNull(30, sql::DataType::INTEGER);
                if (!replayGain.empty()) ps->setString(31, replayGain);
                else ps->setNull(31, sql::DataType::VARCHAR);
                ps->setInt(32, id);
                int result = ps->executeUpdate();
                return result;
            } catch (sql::SQLException &e) {
                LOG(WARNING) << "ERROR: SQLException in " << __FILE__ << " (" << __func__<< ") on line " << __LINE__;
                LOG(WARNING) << "ERROR: " << e.what() << " (MySQL error code: " << e.getErrorCode() << ", SQLState: " << e.getSQLState() << ")";
                bool reconnected = MysqlAccess::getInstance().reconnect();
                LOG(INFO) << (reconnected ? "Successful" : "Failed") << " mysql reconnection";
                if (i == 1) AlertsChannel::getInstance().send(std::string("DB Error (") + __FILE__ + "::" + __func__ + ") : " + e.what());
            }
        }
        return 0;
    }

    int RESong::save() {
        for (int i = 0; i < 2; ++i) {
            try {
                if (id == 0) {
                    sql::PreparedStatement *ps = MysqlAccess::getInstance().getPreparedStatement("select max(id) from RESongs");
                    sql::ResultSet *rs = ps->executeQuery();
                    rs->next();
                    id = rs->getInt(1) + 1;
                    rs->close();
                    delete rs;
                }

                sql::PreparedStatement *ps = MysqlAccess::getInstance().getPreparedStatement("insert into RESongs (id, songidWinfo, songid, shortid, shortidWinfo, artist, album, track, title, time, timeSignature, filename, digitalOnly, compilation, keyStart, keyAccuracy, bpmStart, bpmAccuracy, rating, dateAdded, catalogId, label, remix, numPlays, comments, releaseDate, featuring, keyEnd, disabled, bpmEnd, beatIntensity, replayGain) values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)");
                if (id > 0) ps->setInt(1, id);
                else ps->setNull(1, sql::DataType::INTEGER);
                if (!songidWinfo.empty()) ps->setString(2, songidWinfo);
                else ps->setNull(2, sql::DataType::VARCHAR);
                if (!songid.empty()) ps->setString(3, songid);
                else ps->setNull(3, sql::DataType::VARCHAR);
                if (!shortid.empty()) ps->setString(4, shortid);
                else ps->setNull(4, sql::DataType::VARCHAR);
                if (!shortidWinfo.empty()) ps->setString(5, shortidWinfo);
                else ps->setNull(5, sql::DataType::VARCHAR);
                if (!artist.empty()) ps->setString(6, artist);
                else ps->setNull(6, sql::DataType::VARCHAR);
                if (!album.empty()) ps->setString(7, album);
                else ps->setNull(7, sql::DataType::VARCHAR);
                if (!track.empty()) ps->setString(8, track);
                else ps->setNull(8, sql::DataType::VARCHAR);
                if (!title.empty()) ps->setString(9, title);
                else ps->setNull(9, sql::DataType::VARCHAR);
                if (!time.empty()) ps->setString(10, time);
                else ps->setNull(10, sql::DataType::VARCHAR);
                if (!timeSignature.empty()) ps->setString(11, timeSignature);
                else ps->setNull(11, sql::DataType::VARCHAR);
                if (!filename.empty()) ps->setString(12, filename);
                else ps->setNull(12, sql::DataType::VARCHAR);
                if (!digitalOnly.empty()) ps->setString(13, digitalOnly);
                else ps->setNull(13, sql::DataType::VARCHAR);
                if (!compilation.empty()) ps->setString(14, compilation);
                else ps->setNull(14, sql::DataType::VARCHAR);
                if (!keyStart.empty()) ps->setString(15, keyStart);
                else ps->setNull(15, sql::DataType::VARCHAR);
                if (keyAccuracy > 0) ps->setInt(16, keyAccuracy);
                else ps->setNull(16, sql::DataType::INTEGER);
                if (!bpmStart.empty()) ps->setString(17, bpmStart);
                else ps->setNull(17, sql::DataType::VARCHAR);
                if (bpmAccuracy > 0) ps->setInt(18, bpmAccuracy);
                else ps->setNull(18, sql::DataType::INTEGER);
                if (rating > 0) ps->setInt(19, rating);
                else ps->setNull(19, sql::DataType::INTEGER);
                if (!dateAdded.empty()) ps->setString(20, dateAdded);
                else ps->setNull(20, sql::DataType::VARCHAR);
                if (!catalogId.empty()) ps->setString(21, catalogId);
                else ps->setNull(21, sql::DataType::VARCHAR);
                if (!label.empty()) ps->setString(22, label);
                else ps->setNull(22, sql::DataType::VARCHAR);
                if (!remix.empty()) ps->setString(23, remix);
                else ps->setNull(23, sql::DataType::VARCHAR);
                if (numPlays > 0) ps->setInt(24, numPlays);
                else ps->setNull(24, sql::DataType::INTEGER);
                if (!comments.empty()) ps->setString(25, comments);
                else ps->setNull(25, sql::DataType::VARCHAR);
                if (!releaseDate.empty()) ps->setString(26, releaseDate);
                else ps->setNull(26, sql::DataType::VARCHAR);
                if (!featuring.empty()) ps->setString(27, featuring);
                else ps->setNull(27, sql::DataType::VARCHAR);
                if (!keyEnd.empty()) ps->setString(28, keyEnd);
                else ps->setNull(28, sql::DataType::VARCHAR);
                if (!disabled.empty()) ps->setString(29, disabled);
                else ps->setNull(29, sql::DataType::VARCHAR);
                if (!bpmEnd.empty()) ps->setString(30, bpmEnd);
                else ps->setNull(30, sql::DataType::VARCHAR);
                if (beatIntensity > 0) ps->setInt(31, beatIntensity);
                else ps->setNull(31, sql::DataType::INTEGER);
                if (!replayGain.empty()) ps->setString(32, replayGain);
                else ps->setNull(32, sql::DataType::VARCHAR);
                int saved = ps->executeUpdate();
                if (!saved) {
                    LOG(WARNING) << "Not able to save reSong";
                    return saved;
                } else {
                    return saved;
                }
            } catch (sql::SQLException &e) {
                LOG(WARNING) << "ERROR: SQLException in " << __FILE__ << " (" << __func__<< ") on line " << __LINE__;
                LOG(WARNING) << "ERROR: " << e.what() << " (MySQL error code: " << e.getErrorCode() << ", SQLState: " << e.getSQLState() << ")";
                bool reconnected = MysqlAccess::getInstance().reconnect();
                LOG(INFO) << (reconnected ? "Successful" : "Failed") << " mysql reconnection";
                if (i == 1) AlertsChannel::getInstance().send(std::string("DB Error (") + __FILE__ + "::" + __func__ + ") : " + e.what());
            }
        }
        return 0;
    }

    bool RESong::sync() {
        return true;
    }


# pragma mark accessors

    int RESong::getId() const { return id; }
    void RESong::setId(const int id) { this->id = id; }

    const string& RESong::getSongidWinfo() const { return songidWinfo; }
    void RESong::setSongidWinfo(const string& songidWinfo) { this->songidWinfo = songidWinfo; }

    const string& RESong::getSongid() const { return songid; }
    void RESong::setSongid(const string& songid) { this->songid = songid; }

    const string& RESong::getShortid() const { return shortid; }
    void RESong::setShortid(const string& shortid) { this->shortid = shortid; }

    const string& RESong::getShortidWinfo() const { return shortidWinfo; }
    void RESong::setShortidWinfo(const string& shortidWinfo) { this->shortidWinfo = shortidWinfo; }

    const string& RESong::getArtist() const { return artist; }
    void RESong::setArtist(const string& artist) { this->artist = artist; }

    const string& RESong::getAlbum() const { return album; }
    void RESong::setAlbum(const string& album) { this->album = album; }

    const string& RESong::getTrack() const { return track; }
    void RESong::setTrack(const string& track) { this->track = track; }

    const string& RESong::getTitle() const { return title; }
    void RESong::setTitle(const string& title) { this->title = title; }

    const string& RESong::getTime() const { return time; }
    void RESong::setTime(const string& time) { this->time = time; }

    const string& RESong::getTimeSignature() const { return timeSignature; }
    void RESong::setTimeSignature(const string& timeSignature) { this->timeSignature = timeSignature; }

    const string& RESong::getFilename() const { return filename; }
    void RESong::setFilename(const string& filename) { this->filename = filename; }

    const string& RESong::getDigitalOnly() const { return digitalOnly; }
    void RESong::setDigitalOnly(const string& digitalOnly) { this->digitalOnly = digitalOnly; }

    const string& RESong::getCompilation() const { return compilation; }
    void RESong::setCompilation(const string& compilation) { this->compilation = compilation; }

    const string& RESong::getKeyStart() const { return keyStart; }
    void RESong::setKeyStart(const string& keyStart) { this->keyStart = keyStart; }

    int RESong::getKeyAccuracy() const { return keyAccuracy; }
    void RESong::setKeyAccuracy(const int keyAccuracy) { this->keyAccuracy = keyAccuracy; }

    const string& RESong::getBpmStart() const { return bpmStart; }
    void RESong::setBpmStart(const string& bpmStart) { this->bpmStart = bpmStart; }

    int RESong::getBpmAccuracy() const { return bpmAccuracy; }
    void RESong::setBpmAccuracy(const int bpmAccuracy) { this->bpmAccuracy = bpmAccuracy; }

    int RESong::getRating() const { return rating; }
    void RESong::setRating(const int rating) { this->rating = rating; }

    const string& RESong::getDateAdded() const { return dateAdded; }
    void RESong::setDateAdded(const string& dateAdded) { this->dateAdded = dateAdded; }

    const string& RESong::getCatalogId() const { return catalogId; }
    void RESong::setCatalogId(const string& catalogId) { this->catalogId = catalogId; }

    const string& RESong::getLabel() const { return label; }
    void RESong::setLabel(const string& label) { this->label = label; }

    const string& RESong::getRemix() const { return remix; }
    void RESong::setRemix(const string& remix) { this->remix = remix; }

    int RESong::getNumPlays() const { return numPlays; }
    void RESong::setNumPlays(const int numPlays) { this->numPlays = numPlays; }

    const string& RESong::getComments() const { return comments; }
    void RESong::setComments(const string& comments) { this->comments = comments; }

    const string& RESong::getReleaseDate() const { return releaseDate; }
    void RESong::setReleaseDate(const string& releaseDate) { this->releaseDate = releaseDate; }

    const string& RESong::getFeaturing() const { return featuring; }
    void RESong::setFeaturing(const string& featuring) { this->featuring = featuring; }

    const string& RESong::getKeyEnd() const { return keyEnd; }
    void RESong::setKeyEnd(const string& keyEnd) { this->keyEnd = keyEnd; }

    const string& RESong::getDisabled() const { return disabled; }
    void RESong::setDisabled(const string& disabled) { this->disabled = disabled; }

    const string& RESong::getBpmEnd() const { return bpmEnd; }
    void RESong::setBpmEnd(const string& bpmEnd) { this->bpmEnd = bpmEnd; }

    int RESong::getBeatIntensity() const { return beatIntensity; }
    void RESong::setBeatIntensity(const int beatIntensity) { this->beatIntensity = beatIntensity; }

    const string& RESong::getReplayGain() const { return replayGain; }
    void RESong::setReplayGain(const string& replayGain) { this->replayGain = replayGain; }

    const string& RESong::getStylesBitmask() const { return stylesBitmask; }
    void RESong::setStylesBitmask(const string& stylesBitmask) { this->stylesBitmask = stylesBitmask; }

}
}
