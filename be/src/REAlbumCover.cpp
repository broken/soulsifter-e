//
//  REAlbumCover.cpp
//  soul-sifter
//
//  Created by Robby Neale
//  Generated by generate_model.rb
//

#include "REAlbumCover.h"

#include <cmath>
#include <string>
#include <sstream>

#include <boost/regex.hpp>
#include <boost/algorithm/string.hpp>
#include <jdbc/cppconn/connection.h>
#include <jdbc/cppconn/statement.h>
#include <jdbc/cppconn/prepared_statement.h>
#include <jdbc/cppconn/resultset.h>
#include <jdbc/cppconn/exception.h>
#include <jdbc/cppconn/warning.h>
#include <g3log/g3log.hpp>

#include "MysqlAccess.h"
#include "DTVectorUtil.h"

using namespace std;

namespace dogatech {
namespace soulsifter {

# pragma mark initialization

    REAlbumCover::REAlbumCover() :
    id(0),
    reId(),
    thumbnail() {
    }

    REAlbumCover::REAlbumCover(const REAlbumCover& reAlbumCover) :
    id(reAlbumCover.getId()),
    reId(reAlbumCover.getREId()),
    thumbnail(reAlbumCover.getThumbnail()) {
    }

    void REAlbumCover::operator=(const REAlbumCover& reAlbumCover) {
        id = reAlbumCover.getId();
        reId = reAlbumCover.getREId();
        thumbnail = reAlbumCover.getThumbnail();
    }

    REAlbumCover::~REAlbumCover() {
    }

    void REAlbumCover::clear() {
        id = 0;
        reId.clear();
        thumbnail.clear();
    }

# pragma mark static methods

    void REAlbumCover::populateFields(const sql::ResultSet* rs, REAlbumCover* reAlbumCover) {
        reAlbumCover->setId(rs->getInt("id"));
        reAlbumCover->setREId(rs->getString("reId"));
        reAlbumCover->setThumbnail(rs->getString("thumbnail"));
    }

    REAlbumCover* REAlbumCover::findById(int id) {
        for (int i = 0; i < 2; ++i) {
            try {
                sql::PreparedStatement *ps = MysqlAccess::getInstance().getPreparedStatement("select REAlbumCovers.* from REAlbumCovers where REAlbumCovers.id = ?");
                ps->setInt(1, id);
                sql::ResultSet *rs = ps->executeQuery();
                REAlbumCover *reAlbumCover = NULL;
                if (rs->next()) {
                    reAlbumCover = new REAlbumCover();
                    populateFields(rs, reAlbumCover);
                }
                rs->close();
                delete rs;

                return reAlbumCover;
            } catch (sql::SQLException &e) {
                LOG(WARNING) << "ERROR: SQLException in " << __FILE__ << " (" << __func__<< ") on line " << __LINE__;
                LOG(WARNING) << "ERROR: " << e.what() << " (MySQL error code: " << e.getErrorCode() << ", SQLState: " << e.getSQLState() << ")";
                bool reconnected = MysqlAccess::getInstance().reconnect();
                LOG(INFO) << (reconnected ? "Successful" : "Failed") << " mysql reconnection";
            }
        }
        LOG(FATAL) << "Unable to complete model operation";
    }

    REAlbumCover* REAlbumCover::findByREId(const string& reId) {
        for (int i = 0; i < 2; ++i) {
            try {
                sql::PreparedStatement *ps = MysqlAccess::getInstance().getPreparedStatement("select REAlbumCovers.* from REAlbumCovers where ifnull(reId,'') = ifnull(?,'')");
                if (!reId.empty()) ps->setString(1, reId);
                else ps->setNull(1, sql::DataType::VARCHAR);
                sql::ResultSet *rs = ps->executeQuery();
                REAlbumCover *reAlbumCover = NULL;
                if (rs->next()) {
                    reAlbumCover = new REAlbumCover();
                    populateFields(rs, reAlbumCover);
                }
                rs->close();
                delete rs;

                return reAlbumCover;
            } catch (sql::SQLException &e) {
                LOG(WARNING) << "ERROR: SQLException in " << __FILE__ << " (" << __func__<< ") on line " << __LINE__;
                LOG(WARNING) << "ERROR: " << e.what() << " (MySQL error code: " << e.getErrorCode() << ", SQLState: " << e.getSQLState() << ")";
                bool reconnected = MysqlAccess::getInstance().reconnect();
                LOG(INFO) << (reconnected ? "Successful" : "Failed") << " mysql reconnection";
            }
        }
        LOG(FATAL) << "Unable to complete model operation";
    }

    ResultSetIterator<REAlbumCover>* REAlbumCover::findAll() {
        for (int i = 0; i < 2; ++i) {
            try {
                sql::PreparedStatement *ps = MysqlAccess::getInstance().getPreparedStatement("select REAlbumCovers.* from REAlbumCovers");
                sql::ResultSet *rs = ps->executeQuery();
                ResultSetIterator<REAlbumCover> *dtrs = new ResultSetIterator<REAlbumCover>(rs);
                return dtrs;
            } catch (sql::SQLException &e) {
                LOG(WARNING) << "ERROR: SQLException in " << __FILE__ << " (" << __func__<< ") on line " << __LINE__;
                LOG(WARNING) << "ERROR: " << e.what() << " (MySQL error code: " << e.getErrorCode() << ", SQLState: " << e.getSQLState() << ")";
                bool reconnected = MysqlAccess::getInstance().reconnect();
                LOG(INFO) << (reconnected ? "Successful" : "Failed") << " mysql reconnection";
            }
        }
        LOG(FATAL) << "Unable to complete model operation";
    }

# pragma mark persistence

    int REAlbumCover::update() {
        for (int i = 0; i < 2; ++i) {
            try {

                sql::PreparedStatement *ps = MysqlAccess::getInstance().getPreparedStatement("update REAlbumCovers set reId=?, thumbnail=? where id=?");
                if (!reId.empty()) ps->setString(1, reId);
                else ps->setNull(1, sql::DataType::VARCHAR);
                if (!thumbnail.empty()) ps->setString(2, thumbnail);
                else ps->setNull(2, sql::DataType::VARCHAR);
                ps->setInt(3, id);
                int result = ps->executeUpdate();
                return result;
            } catch (sql::SQLException &e) {
                LOG(WARNING) << "ERROR: SQLException in " << __FILE__ << " (" << __func__<< ") on line " << __LINE__;
                LOG(WARNING) << "ERROR: " << e.what() << " (MySQL error code: " << e.getErrorCode() << ", SQLState: " << e.getSQLState() << ")";
                bool reconnected = MysqlAccess::getInstance().reconnect();
                LOG(INFO) << (reconnected ? "Successful" : "Failed") << " mysql reconnection";
            }
        }
        LOG(FATAL) << "Unable to complete model operation";
    }

    int REAlbumCover::save() {
        for (int i = 0; i < 2; ++i) {
            try {

                sql::PreparedStatement *ps = MysqlAccess::getInstance().getPreparedStatement("insert into REAlbumCovers (reId, thumbnail) values (?, ?)");
                if (!reId.empty()) ps->setString(1, reId);
                else ps->setNull(1, sql::DataType::VARCHAR);
                if (!thumbnail.empty()) ps->setString(2, thumbnail);
                else ps->setNull(2, sql::DataType::VARCHAR);
                int saved = ps->executeUpdate();
                if (!saved) {
                    LOG(WARNING) << "Not able to save reAlbumCover";
                    return saved;
                } else {
                    id = MysqlAccess::getInstance().getLastInsertId();
                    if (id == 0) {
                        LOG(WARNING) << "Inserted reAlbumCover, but unable to retreive inserted ID.";
                        return saved;
                    }
                    return saved;
                }
            } catch (sql::SQLException &e) {
                LOG(WARNING) << "ERROR: SQLException in " << __FILE__ << " (" << __func__<< ") on line " << __LINE__;
                LOG(WARNING) << "ERROR: " << e.what() << " (MySQL error code: " << e.getErrorCode() << ", SQLState: " << e.getSQLState() << ")";
                bool reconnected = MysqlAccess::getInstance().reconnect();
                LOG(INFO) << (reconnected ? "Successful" : "Failed") << " mysql reconnection";
            }
        }
        LOG(FATAL) << "Unable to complete model operation";
    }

    bool REAlbumCover::sync() {
        REAlbumCover* reAlbumCover = findById(id);
        if (!reAlbumCover) reAlbumCover = findByREId(getREId());
        if (!reAlbumCover) return true;

        // check fields
        bool needsUpdate = false;
        boost::regex decimal("(-?\\d+)\\.?\\d*");
        boost::smatch match1;
        boost::smatch match2;
        if (id != reAlbumCover->getId()) {
            if (id) {
                LOG(INFO) << "updating reAlbumCover " << id << " id from " << reAlbumCover->getId() << " to " << id;
                needsUpdate = true;
            } else {
                id = reAlbumCover->getId();
            }
        }
        if (reId.compare(reAlbumCover->getREId())  && (!boost::regex_match(reId, match1, decimal) || !boost::regex_match(reAlbumCover->getREId(), match2, decimal) || match1[1].str().compare(match2[1].str()))) {
            if (!reId.empty()) {
                LOG(INFO) << "updating reAlbumCover " << id << " reId from " << reAlbumCover->getREId() << " to " << reId;
                needsUpdate = true;
            } else {
                reId = reAlbumCover->getREId();
            }
        }
        if (thumbnail.compare(reAlbumCover->getThumbnail())  && (!boost::regex_match(thumbnail, match1, decimal) || !boost::regex_match(reAlbumCover->getThumbnail(), match2, decimal) || match1[1].str().compare(match2[1].str()))) {
            if (!thumbnail.empty()) {
                LOG(INFO) << "updating reAlbumCover " << id << " thumbnail from " << reAlbumCover->getThumbnail() << " to " << thumbnail;
                needsUpdate = true;
            } else {
                thumbnail = reAlbumCover->getThumbnail();
            }
        }
        return needsUpdate;
    }


# pragma mark accessors

    int REAlbumCover::getId() const { return id; }
    void REAlbumCover::setId(const int id) { this->id = id; }

    const string& REAlbumCover::getREId() const { return reId; }
    void REAlbumCover::setREId(const string& reId) { this->reId = reId; }

    const string& REAlbumCover::getThumbnail() const { return thumbnail; }
    void REAlbumCover::setThumbnail(const string& thumbnail) { this->thumbnail = thumbnail; }

}
}
